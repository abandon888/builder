## 素材列表

#### AssetList

暴漏给客户端，返回素材列表

```Go
type CategoryCollection map[string]string
type ListAssetsParams struct {
        .....
        // just this field changed
        Category *CategoryCollection
        .....
}
func (ctrl *Controller)ListAssets(ctx context.Context, params *ListAssetsParams) (*model.ByPage[model.Asset], error){
    index = nil
    if ListAssetsParams.keyword != nil{
        // word to vector
        vec = Embedding(ListAssetsParams.keyword)
        // search in vector database
        index = model.searchByEmbedding(vec)
    }
    assets = model.ListAssets(ctx, ctrl.db, params.Pagination, wheres, orders, index)
    return assets
}
```

#### Embedding（AI）

实现 将文本encode的功能

会调用 AI 侧能力

```Go
type EmbeddingParams struct {
    // word is the word to be embedded.
    Word string `json:"word"`
}
type EmbeddingResult struct{
    // embedding is the vector transformed by the statement
    Embedding []float64 `json:"embedding"`
}
func (ctrl *Controller) Embedding(Word string){
    // call aigc service
    ctrl.aicgService.Call(ctx, http.MethodPost, "/embedding", &Params, &Result)
    return Result
}
```

POST /embedding

- Request body

```JSON
{
  "word": "string",
}
```

- Response body

```JSON
{
  "embedding": ["int"],
}
```

## 文本生成图片

#### TextGenSpriteImage

```Go
type GenSpriteImageParams{
    Category CategoryCollection
    Keyword string
}
type GenSpriteImageResult{
    ImageJobId string
}
func (ctrl *Controller) GenSpriteImage(ctx context.Context, c *GenSpriteImageParams)(*GenSpriteImageResult , err){
    // combine the category and keyword in the request into text suitable for input into ai
    textDesc = paramsToText(category, keyword)
    // since the ai side currently only supports synchronization 
    // asynchronous is performed here in the backend.
    jobId = model.AddJob(jobType)
    // the coroutine request calls the ai-side service
    go TextGenImage(jobId, textDesc)
    // return
    return GenSpriteImageResult
}
```

#### TextGenBackdropImage

```Go
type GenBackdropImageParams{
    Category CategoryCollection
    Keyword string
    Width int
    Height int
}
type GenBackdropImageResult{
    ImageJobId string
}
func (ctrl *Controller) GenBackdropImage(ctx context.Context, params *GenBackdropImageParams){
    // combine the category, keyword and resolution in the request into 
    // text suitable for input into ai
    textDesc = paramsToText(params.category, params.keyword)
    // Since the ai side currently only supports synchronization 
    // asynchronous is performed here in the backend.
    jobId = model.AddJob(jobType)
    // the coroutine request calls the ai-side service
    go TextGenImage(jobId, textDesc)
    // return
    return GenBackdropImageResult
}
```

#### TextGenImage（AI侧）

```Go
type TextGenImageParams struct {
    // the description of generate
    TextDesc string `json:"textDesc"`
}
type TextGenImageResult struct{
    // the url of generate
    ImageUrl string `json:"imageUrl"`
}
func TextGenImage(jobId int, params *TextGenImageParams){
    // calls the ai-side service
    ctrl.aicgService.Call(ctx, http.MethodPost, "/textGenImage", &params, &result)
    // write results back to database
    model.UpdateAsset(jobId, result.ImageUrl)
}
```

POST /textGenImage

- Request body

```JSON
{
  "textDesc": "string",
}
```

- Response body

```JSON
{
  "imageUrl": "string",
}
```

## 图片生成精灵

#### ImageGenSprite

```Go
type ImageGenSpriteParams struct{
    ImageJobId string `json:"imageJobId"`
}
type ImageGenSpriteResult struct {

    JobId string `json:"jobId"`
}
func (ctrl *Controller) ImageGenSprite(ctx context.Context, params *ImageGenSpriteParams){
    // get the URL of the AI-generated image through the jobid generated by the AI image.
    imageUrl = model.getImageUrl(params.ImageJobId)
    // Since the ai side currently only supports synchronization 
    // asynchronous is performed here in the backend.
    jobId = model.AddJob(jobType)
    // the coroutine request calls the ai-side service
    go genAsset(jobId, imageUrl)
    // return
    return imageGenSpriteResult
}
```

#### ImageGenAsset（AI侧）

```Go
type imageGenSpriteParams struct {
    // Word is the word to be embedded.
    ImageUrl string `json:"imageUrl"`
}

type genResult struct{
    
    Files FileCollection `json:"files"`
}

type FileCollection map[string]string

func genAsset(jobId int,imageUrl string){
    result = imageGenSpriteParams {
        ImageUrl = imageUrl
    }
    // calls the ai-side service
    ctrl.aicgService.Call(ctx, http.MethodPost, "/imageGenSprite", &params, &result)
    // write results back to database
    model.UpdateJob(jobId , result)
}
```

POST /imageGenSprite

- Request body

```JSON
{
  "imageUrl": "string",
}
```

- Response body

```JSON
{
  "files": {
      "imageUrl": "string",
      "skeletonUrl" : "string",
      "animMeshUrl" : "string",
      "frameDataUrl" : "string"
  },
}
```

## 查询生成状态

#### GenStatus

```Go
type GenStatusParams struct {
    JobId string `json:"jobId"`
}
type genResult{
    jobId string 'json:"jobId"'
    jobType int 'json:"jobType"'
    files FileCollection `json:"files"`
}


type GenStatusResult struct{
    Status int 'json:"status"'
    Result GenResult`json:"result"`
}

func (ctrl *Controller) GenStatus(ctx context.Context, params *GenStatusParams){
    // query job status
    genStatusResult = model.getJob(params)
    return genStatusResult
}
```

## 收藏/添加模块

#### ExportAiAsset

```Go
type ExportAiAssetParams{
    JobId string 'json:"jobId"'
}
type ExportAiAssetResult{
    AssetId string 'json:"assetId"'
}
func (ctrl *Controller) ExportAiAsset(ctx context.Context, params *ExportAiAssetParams){
    addAssetParams = model.getJob(params.JobId)
    //write to vector database
    model.addByVec(addAssetParams)
    // write to database
    asset = model.AddAsset(ctx, addAssetParams)
    return asset.id
}
```

#### History

```Go
type HistoryParams{
    AssetId string 'json:"assetId"'
}
func (ctrl *Controller) AddHistory(){
}
```

#### Favorite

```Go
type FavoriteParams{
    AssetId string 'json:"assetId"'
}
func AddFavorite(){
}
```